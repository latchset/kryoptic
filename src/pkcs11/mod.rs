// Copyright 2025 Simo Sorce
// See LICENSE.txt file for terms

//! This module is automatically generated by `bindgen` from the
//! `PKCS #11 Headers` and includes all constants and objects
//! defined in the `PKCS #11 API` version selected for the build

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use crate::error::Result;

include!(concat!(env!("OUT_DIR"), "/pkcs11_bindings.rs"));

// types that need different mutability than bindgen provides
pub type CK_FUNCTION_LIST_PTR = *const CK_FUNCTION_LIST;
pub type CK_FUNCTION_LIST_3_0_PTR = *const CK_FUNCTION_LIST_3_0;
pub type CK_FUNCTION_LIST_3_2_PTR = *const CK_FUNCTION_LIST_3_2;
// this is wrongly converted on 32b architecture to too large value
// which can not be represented in CK_ULONG.
pub const CK_UNAVAILABLE_INFORMATION: CK_ULONG = CK_ULONG::MAX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CK_INTERFACE {
    pub pInterfaceName: *const CK_CHAR,
    pub pFunctionList: *const ::std::os::raw::c_void,
    pub flags: CK_FLAGS,
}
unsafe impl Sync for CK_INTERFACE {}
unsafe impl Send for CK_INTERFACE {}

pub mod vendor;

macro_rules! err_to_elem {
    ($name:ident) => {
        ($name, stringify!($name))
    };
}

/// Static map with error num -> error string pairs
static ERRORMAP: [(CK_ULONG, &str); 104] = [
    err_to_elem!(CKR_OK),
    err_to_elem!(CKR_CANCEL),
    err_to_elem!(CKR_HOST_MEMORY),
    err_to_elem!(CKR_SLOT_ID_INVALID),
    err_to_elem!(CKR_GENERAL_ERROR),
    err_to_elem!(CKR_FUNCTION_FAILED),
    err_to_elem!(CKR_ARGUMENTS_BAD),
    err_to_elem!(CKR_NO_EVENT),
    err_to_elem!(CKR_NEED_TO_CREATE_THREADS),
    err_to_elem!(CKR_CANT_LOCK),
    err_to_elem!(CKR_ATTRIBUTE_READ_ONLY),
    err_to_elem!(CKR_ATTRIBUTE_SENSITIVE),
    err_to_elem!(CKR_ATTRIBUTE_TYPE_INVALID),
    err_to_elem!(CKR_ATTRIBUTE_VALUE_INVALID),
    err_to_elem!(CKR_ACTION_PROHIBITED),
    err_to_elem!(CKR_DATA_INVALID),
    err_to_elem!(CKR_DATA_LEN_RANGE),
    err_to_elem!(CKR_DEVICE_ERROR),
    err_to_elem!(CKR_DEVICE_MEMORY),
    err_to_elem!(CKR_DEVICE_REMOVED),
    err_to_elem!(CKR_ENCRYPTED_DATA_INVALID),
    err_to_elem!(CKR_ENCRYPTED_DATA_LEN_RANGE),
    err_to_elem!(CKR_AEAD_DECRYPT_FAILED),
    err_to_elem!(CKR_FUNCTION_CANCELED),
    err_to_elem!(CKR_FUNCTION_NOT_PARALLEL),
    err_to_elem!(CKR_FUNCTION_NOT_SUPPORTED),
    err_to_elem!(CKR_KEY_HANDLE_INVALID),
    err_to_elem!(CKR_KEY_SIZE_RANGE),
    err_to_elem!(CKR_KEY_TYPE_INCONSISTENT),
    err_to_elem!(CKR_KEY_NOT_NEEDED),
    err_to_elem!(CKR_KEY_CHANGED),
    err_to_elem!(CKR_KEY_NEEDED),
    err_to_elem!(CKR_KEY_INDIGESTIBLE),
    err_to_elem!(CKR_KEY_FUNCTION_NOT_PERMITTED),
    err_to_elem!(CKR_KEY_NOT_WRAPPABLE),
    err_to_elem!(CKR_KEY_UNEXTRACTABLE),
    err_to_elem!(CKR_MECHANISM_INVALID),
    err_to_elem!(CKR_MECHANISM_PARAM_INVALID),
    err_to_elem!(CKR_OBJECT_HANDLE_INVALID),
    err_to_elem!(CKR_OPERATION_ACTIVE),
    err_to_elem!(CKR_OPERATION_NOT_INITIALIZED),
    err_to_elem!(CKR_PIN_INCORRECT),
    err_to_elem!(CKR_PIN_INVALID),
    err_to_elem!(CKR_PIN_LEN_RANGE),
    err_to_elem!(CKR_PIN_EXPIRED),
    err_to_elem!(CKR_PIN_LOCKED),
    err_to_elem!(CKR_SESSION_CLOSED),
    err_to_elem!(CKR_SESSION_COUNT),
    err_to_elem!(CKR_SESSION_HANDLE_INVALID),
    err_to_elem!(CKR_SESSION_PARALLEL_NOT_SUPPORTED),
    err_to_elem!(CKR_SESSION_READ_ONLY),
    err_to_elem!(CKR_SESSION_EXISTS),
    err_to_elem!(CKR_SESSION_READ_ONLY_EXISTS),
    err_to_elem!(CKR_SESSION_READ_WRITE_SO_EXISTS),
    err_to_elem!(CKR_SIGNATURE_INVALID),
    err_to_elem!(CKR_SIGNATURE_LEN_RANGE),
    err_to_elem!(CKR_TEMPLATE_INCOMPLETE),
    err_to_elem!(CKR_TEMPLATE_INCONSISTENT),
    err_to_elem!(CKR_TOKEN_NOT_PRESENT),
    err_to_elem!(CKR_TOKEN_NOT_RECOGNIZED),
    err_to_elem!(CKR_TOKEN_WRITE_PROTECTED),
    err_to_elem!(CKR_UNWRAPPING_KEY_HANDLE_INVALID),
    err_to_elem!(CKR_UNWRAPPING_KEY_SIZE_RANGE),
    err_to_elem!(CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT),
    err_to_elem!(CKR_USER_ALREADY_LOGGED_IN),
    err_to_elem!(CKR_USER_NOT_LOGGED_IN),
    err_to_elem!(CKR_USER_PIN_NOT_INITIALIZED),
    err_to_elem!(CKR_USER_TYPE_INVALID),
    err_to_elem!(CKR_USER_ANOTHER_ALREADY_LOGGED_IN),
    err_to_elem!(CKR_USER_TOO_MANY_TYPES),
    err_to_elem!(CKR_WRAPPED_KEY_INVALID),
    err_to_elem!(CKR_WRAPPED_KEY_LEN_RANGE),
    err_to_elem!(CKR_WRAPPING_KEY_HANDLE_INVALID),
    err_to_elem!(CKR_WRAPPING_KEY_SIZE_RANGE),
    err_to_elem!(CKR_WRAPPING_KEY_TYPE_INCONSISTENT),
    err_to_elem!(CKR_RANDOM_SEED_NOT_SUPPORTED),
    err_to_elem!(CKR_RANDOM_NO_RNG),
    err_to_elem!(CKR_DOMAIN_PARAMS_INVALID),
    err_to_elem!(CKR_CURVE_NOT_SUPPORTED),
    err_to_elem!(CKR_BUFFER_TOO_SMALL),
    err_to_elem!(CKR_SAVED_STATE_INVALID),
    err_to_elem!(CKR_INFORMATION_SENSITIVE),
    err_to_elem!(CKR_STATE_UNSAVEABLE),
    err_to_elem!(CKR_CRYPTOKI_NOT_INITIALIZED),
    err_to_elem!(CKR_CRYPTOKI_ALREADY_INITIALIZED),
    err_to_elem!(CKR_MUTEX_BAD),
    err_to_elem!(CKR_MUTEX_NOT_LOCKED),
    err_to_elem!(CKR_NEW_PIN_MODE),
    err_to_elem!(CKR_NEXT_OTP),
    err_to_elem!(CKR_EXCEEDED_MAX_ITERATIONS),
    err_to_elem!(CKR_FIPS_SELF_TEST_FAILED),
    err_to_elem!(CKR_LIBRARY_LOAD_FAILED),
    err_to_elem!(CKR_PIN_TOO_WEAK),
    err_to_elem!(CKR_PUBLIC_KEY_INVALID),
    err_to_elem!(CKR_FUNCTION_REJECTED),
    err_to_elem!(CKR_TOKEN_RESOURCE_EXCEEDED),
    err_to_elem!(CKR_OPERATION_CANCEL_FAILED),
    err_to_elem!(CKR_KEY_EXHAUSTED),
    err_to_elem!(CKR_PENDING),
    err_to_elem!(CKR_SESSION_ASYNC_NOT_SUPPORTED),
    err_to_elem!(CKR_SEED_RANDOM_REQUIRED),
    err_to_elem!(CKR_OPERATION_NOT_VALIDATED),
    err_to_elem!(CKR_TOKEN_NOT_INITIALIZED),
    err_to_elem!(CKR_PARAMETER_SET_NOT_SUPPORTED),
];

/// Function to return an error string from a CK_RV error.
///
/// It never fails and returns "Unknown Error XX" where XX
/// is an unknown error number (in hexadecimal notation).
pub fn ckrv_to_string(ckrv: CK_ULONG) -> String {
    for e in ERRORMAP {
        if e.0 == ckrv {
            return format!("{}({})", e.1, e.0);
        }
    }
    return format!("Unknown Error {:x}", ckrv);
}

/// Convenience helper to copy a pointer+length obtained via FFI into a
/// valid Vector of bytes.
macro_rules! bytes_to_vec {
    ($ptr:expr, $len:expr) => {{
        let ptr = $ptr as *const u8;
        let size = usize::try_from($len).unwrap();
        if ptr == std::ptr::null_mut() || size == 0 {
            Vec::new()
        } else {
            let mut v = Vec::<u8>::with_capacity(size);
            unsafe {
                std::ptr::copy_nonoverlapping(ptr, v.as_mut_ptr(), size);
                v.set_len(size);
            }
            v
        }
    }};
}

/// Date digits separator
const ASCII_DASH: u8 = b'-';
/// Smallest ASCII value for a date digit
const MIN_ASCII_DIGIT: u8 = b'0';
/// Largest ASCII value for a date digit
const MAX_ASCII_DIGIT: u8 = b'9';

/// Converts a vector of bytes into a CK_DATE structure with some validation
///
/// The data is checked to ensure only ASCII values of numbers are present,
/// but there is no validation that the resulting date is in any way valid.
pub fn vec_to_date_validate(val: Vec<u8>) -> Result<CK_DATE> {
    if val.len() != 8 {
        return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
    }
    for n in val.iter() {
        if *n < MIN_ASCII_DIGIT || *n > MAX_ASCII_DIGIT {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
    }
    Ok(CK_DATE {
        year: [val[0], val[1], val[2], val[3]],
        month: [val[5], val[6]],
        day: [val[8], val[9]],
    })
}

/// Parses a string as a date
///
/// Returns a CK_DATE on success
pub fn string_to_ck_date(date: &str) -> Result<CK_DATE> {
    let s = date.as_bytes().to_vec();
    if s.len() != 10 {
        return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
    }
    if s[4] != ASCII_DASH || s[7] != ASCII_DASH {
        return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
    }
    let mut buf = Vec::with_capacity(8);
    buf[0] = s[0];
    buf[1] = s[1];
    buf[2] = s[2];
    buf[3] = s[3];
    buf[4] = s[5];
    buf[5] = s[6];
    buf[6] = s[8];
    buf[7] = s[9];
    vec_to_date_validate(buf)
}

impl CK_ATTRIBUTE {
    /// Returns the internal data memory buffer as a CK_ULONG
    ///
    /// Errors out if the data size does not match the size of a CK_ULONG
    pub fn to_ulong(&self) -> Result<CK_ULONG> {
        if self.ulValueLen != std::mem::size_of::<CK_ULONG>() as CK_ULONG {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
        Ok(unsafe { *(self.pValue as CK_ULONG_PTR) })
    }

    /// Returns the internal data memory buffer as a bool
    ///
    /// Errors out if the data size does not match the size of a CK_BBOOL
    pub fn to_bool(self) -> Result<bool> {
        if self.ulValueLen != std::mem::size_of::<CK_BBOOL>() as CK_ULONG {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
        let val: CK_BBOOL = unsafe { *(self.pValue as CK_BBOOL_PTR) };
        if val == 0 {
            Ok(false)
        } else {
            Ok(true)
        }
    }

    /// Returns the internal data memory buffer as a String
    ///
    /// Errors out if the data size does not match or the buffer is
    /// not parseable as a UTF8 string.
    pub fn to_string(&self) -> Result<String> {
        if self.ulValueLen == 0 {
            return Ok(String::new());
        }
        if self.pValue.is_null() {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
        let buf: &[u8] = unsafe {
            std::slice::from_raw_parts(
                self.pValue as *const _,
                usize::try_from(self.ulValueLen)?,
            )
        };
        match std::str::from_utf8(buf) {
            Ok(s) => Ok(s.to_string()),
            Err(_) => Err(CKR_ATTRIBUTE_VALUE_INVALID)?,
        }
    }

    /// Returns the internal data memory buffer as a slice
    ///
    /// Errors out if the internal data pointer is null
    pub fn to_slice(&self) -> Result<&[u8]> {
        if self.ulValueLen == 0 {
            return Ok(&[]);
        }
        if self.pValue.is_null() {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
        Ok(unsafe {
            std::slice::from_raw_parts(
                self.pValue as *const u8,
                usize::try_from(self.ulValueLen)?,
            )
        })
    }

    /// Returns a copy of the internal buffer as an vector
    ///
    /// Returns an empty vector if the internal buffer pointer is null
    pub fn to_buf(&self) -> Result<Vec<u8>> {
        Ok(bytes_to_vec!(self.pValue, self.ulValueLen))
    }

    /// Returns the internal buffer as a CK_DATE
    ///
    /// Errors out if parsing the buffer as a date fails
    pub fn to_date(&self) -> Result<CK_DATE> {
        if self.ulValueLen == 0 {
            /* set 0000-00-00 */
            return Ok(CK_DATE {
                year: [b'0', b'0', b'0', b'0'],
                month: [b'0', b'0'],
                day: [b'0', b'0'],
            });
        }
        if self.pValue.is_null() {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
        if self.ulValueLen != 8 {
            return Err(CKR_ATTRIBUTE_VALUE_INVALID)?;
        }
        vec_to_date_validate(bytes_to_vec!(self.pValue, self.ulValueLen))
    }
}
