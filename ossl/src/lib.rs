// Copyright 2025 Simo Sorce
// See LICENSE.txt file for terms

//! This package provides common utilities, wrappers, and constants for interacting
//! with the OpenSSL library (`libcrypto`) via its C API, primarily focusing on
//! the EVP (high-level) interface and parameter handling (`OSSL_PARAM`).

/// Part of this module is automatically generated by bindgen from the OpenSSL
/// Headers and includes a selection of functions and other items needed to
/// access the libcrypto/libfips functions needed.
pub mod bindings {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(dead_code)]
    #![allow(non_snake_case)]
    include!(concat!(env!("OUT_DIR"), "/ossl_bindings.rs"));
}

use std::borrow::Cow;
use std::ffi::{c_char, c_int, c_long, c_uchar, c_uint, c_ulong, c_void, CStr};

use crate::bindings::*;

#[cfg(feature = "fips")]
pub mod fips;

/// Convenience macro to type cast any pointer into a mutable void
/// NOTE(1): bindgen always turns void pointers to mutable ones, but in most
/// cases the pointed data nor the pointer itself are mutated, so this casts
/// any pointer regardless of its original mutability.
/// NOTE(2): we do not wrap in unsafe{} because often this macro is invoked
/// from an unsafe{} code block.
///
/// This macro is UNSAFE, use carefully.
macro_rules! void_ptr {
    ($ptr:expr) => {
        $ptr as *const _ as *mut c_void
    };
}
pub(crate) use void_ptr;

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[non_exhaustive]
pub enum ErrorKind {
    /// OpenSSL returned a NULL ptr as an error
    NullPtr,
    /// OpenSSL returned a 0 c_int as an error
    OsslError,
    /// A falure resulting from wrong key usage
    KeyError,
    /// A warpper error
    WrapperError,
    /// A buffer is not of the correct size
    BufferSize,
}

#[derive(Debug)]
pub struct Error {
    kind: ErrorKind,
}

impl Error {
    pub fn new(k: ErrorKind) -> Error {
        Error { kind: k }
    }

    pub fn kind(&self) -> ErrorKind {
        self.kind
    }
}

impl From<std::num::TryFromIntError> for Error {
    /// Maps an integer conversion error to a generic error
    fn from(_error: std::num::TryFromIntError) -> Error {
        Error::new(ErrorKind::WrapperError)
    }
}

impl From<std::io::Error> for Error {
    /// Maps an io error to a generic error
    fn from(_error: std::io::Error) -> Error {
        Error::new(ErrorKind::WrapperError)
    }
}

#[cfg(all(feature = "log", feature = "fips"))]
pub fn ossl_err_stack() -> String {
    /* there is no external error management with fips builds */
    "".to_string()
}

#[cfg(all(feature = "log", not(feature = "fips")))]
pub fn ossl_err_stack() -> String {
    // Use a mem bio to "print out" the error stack
    let mut bio = std::ptr::null_mut();
    let bio_method = unsafe { BIO_s_mem() };
    if !bio_method.is_null() {
        bio = unsafe { BIO_new(bio_method) };
    }
    if bio.is_null() {
        return "Failed to fetch OpenSSL Error Stack".to_string();
    }
    unsafe { ERR_print_errors(bio) };

    /* retrieve the mem bio data as a long string, with embedded \n */
    let mut raw_mem: *mut c_char = std::ptr::null_mut();
    let raw_len = unsafe {
        BIO_ctrl(bio, BIO_CTRL_INFO as c_int, 0, void_ptr!(&mut raw_mem))
    };

    if raw_mem.is_null() || raw_len == 0 {
        return "Failed to get error from OpenSSL's Error Stack".to_string();
    }

    /* copy this buffer to a vector so we can turn it into a Rust String */
    let mut vec = vec![0u8; raw_len as usize];
    unsafe {
        std::ptr::copy_nonoverlapping(
            raw_mem as *const u8,
            vec.as_mut_ptr(),
            vec.len(),
        );
    }

    // remove final newline if any
    while vec[vec.len() - 1] == b'\n' {
        let _ = vec.pop();
    }
    match String::from_utf8(vec) {
        Ok(s) => s,
        Err(e) => format!("Failed to parse OpenSSL Error Stack: [{:?}]", e),
    }
}

macro_rules! trace_ossl {
    ($name:expr) => {
        #[cfg(feature = "log")]
        {
            use log::error;
            error!(
                "{}:{}: {} failed: [{}]",
                file!(),
                line!(),
                $name,
                ossl_err_stack()
            );
        }
    };
}

/// A structure representing the main crypto library context
pub struct OsslContext {
    context: *mut OSSL_LIB_CTX,
}

impl OsslContext {
    pub fn new_lib_ctx() -> OsslContext {
        OsslContext {
            context: unsafe { OSSL_LIB_CTX_new() },
        }
    }

    #[allow(dead_code)]
    pub(crate) fn from_ctx(ctx: *mut OSSL_LIB_CTX) -> OsslContext {
        OsslContext { context: ctx }
    }

    pub fn ptr(&self) -> *mut OSSL_LIB_CTX {
        self.context
    }
}

unsafe impl Send for OsslContext {}
unsafe impl Sync for OsslContext {}

/// Wrapper around OpenSSL's `BIGNUM` type for handling large numbers.
/// Manages the lifecycle and provides conversion methods.
#[derive(Debug)]
struct BigNum {
    bn: *const BIGNUM,
}

impl BigNum {
    /// Allocates a new BIGNUM from a vector of bytes with the binary
    /// representation of the number in big endian byte order (most
    /// significant byte first).
    ///
    /// Returns a wrapped `BigNum` or an error if the import fails.
    pub fn from_bigendian_vec(v: &Vec<u8>) -> Result<BigNum, Error> {
        let bn = unsafe {
            BN_bin2bn(
                v.as_ptr() as *mut u8,
                c_int::try_from(v.len())?,
                std::ptr::null_mut(),
            )
        };
        if bn.is_null() {
            trace_ossl!("BN_bin2bn()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(BigNum {
            bn: bn as *const BIGNUM,
        })
    }

    /// Calculates the minimum number of bytes needed to represent the `BIGNUM`.
    pub fn len(&self) -> Result<usize, Error> {
        let x = unsafe { (BN_num_bits(self.bn) + 7) / 8 };
        Ok(usize::try_from(x)?)
    }

    /// Creates a `BigNum` by extracting it from an `OSSL_PARAM`.
    pub fn from_param(p: *const OSSL_PARAM) -> Result<BigNum, Error> {
        let mut bn: *mut BIGNUM = std::ptr::null_mut();
        if unsafe { OSSL_PARAM_get_BN(p, &mut bn) } != 1 {
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(BigNum {
            bn: bn as *const BIGNUM,
        })
    }

    /// Converts the `BIGNUM` to a byte vector in native-endian format, padded
    /// to the required length. Primarily used internally for constructing
    /// `OSSL_PARAM`s.
    pub fn to_native_vec(&self) -> Result<Vec<u8>, Error> {
        let mut v = vec![0u8; self.len()?];
        if v.len() == 0 {
            v.push(0);
        }
        let ret = unsafe {
            BN_bn2nativepad(self.bn, v.as_mut_ptr(), c_int::try_from(v.len())?)
        };
        if ret < 1 {
            trace_ossl!("BN_bn2nativepad()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(v)
    }

    /// Converts the `BIGNUM` to a byte vector in big-endian format (standard
    /// external representation).
    pub fn to_bigendian_vec(&self) -> Result<Vec<u8>, Error> {
        let len = self.len()?;
        let mut v = vec![0u8; self.len()?];
        let ret = unsafe { BN_bn2bin(self.bn, v.as_mut_ptr()) };
        if usize::try_from(ret)? != len {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        Ok(v)
    }
}

impl Drop for BigNum {
    fn drop(&mut self) {
        unsafe {
            BN_free(self.bn as *mut BIGNUM);
        }
    }
}

/// Helper container to keep references around in structure that deal with
/// FFI structures that reference pointers, like arrays of CK_ATTRIBUTEs and
/// OSSL_PARAMs
#[derive(Debug)]
#[allow(dead_code)]
pub enum BorrowedReference<'a> {
    CharBool(&'a c_uchar),
    Int(&'a c_int),
    Slice(&'a [u8]),
    Vector(&'a Vec<u8>),
    Uint(&'a c_uint),
    Ulong(&'a c_ulong),
    Usize(&'a usize),
}

/// A safe builder and manager for OpenSSL `OSSL_PARAM` arrays.
///
/// `OSSL_PARAM` is the primary way to pass detailed parameters (like key
/// components, algorithm settings) to many OpenSSL 3+ EVP functions.
///
/// This struct handles memory management (including optional zeroization) and
/// lifetime complexities when constructing these arrays from Rust types.
#[derive(Debug)]
pub struct OsslParam<'a> {
    /// Storage for owned byte buffers backing some parameters.
    v: Vec<Vec<u8>>,
    /// The actual `OSSL_PARAM` array, potentially borrowed or owned.
    p: Cow<'a, [OSSL_PARAM]>,
    /// Flag indicating if the construction of the params has been finalized
    finalized: bool,
    /// Flag indicating the storage buffer should be zeroized on drop
    pub zeroize: bool,
    /// Flag indicating `p` contains an owned pointer we are responsible
    /// for freeing
    pub freeptr: bool,
    /// Use an enum to hold references to data we need to keep around as
    /// a pointer to their data is stored in the OSSL_PARAM array
    br: Vec<BorrowedReference<'a>>,
}

impl Drop for OsslParam<'_> {
    fn drop(&mut self) {
        if self.zeroize {
            while let Some(mut v) = self.v.pop() {
                unsafe {
                    OPENSSL_cleanse(void_ptr!(v.as_mut_ptr()), v.len());
                }
            }
        }
        if self.freeptr {
            unsafe {
                OSSL_PARAM_free(self.p.as_ref().as_ptr() as *mut OSSL_PARAM);
            }
        }
    }
}

impl<'a> OsslParam<'a> {
    /// Creates a new, empty `OsslParam` builder.
    #[allow(dead_code)]
    pub fn new() -> OsslParam<'a> {
        Self::with_capacity(0)
    }

    /// Creates a new, empty `OsslParam` builder with a specific initial
    /// capacity.
    pub fn with_capacity(capacity: usize) -> OsslParam<'a> {
        OsslParam {
            v: Vec::new(),
            p: Cow::Owned(Vec::with_capacity(capacity + 1)),
            finalized: false,
            zeroize: false,
            freeptr: false,
            br: Vec::new(),
        }
    }

    /// Creates an `OsslParam` instance by borrowing an existing `OSSL_PARAM`
    /// array from OpenSSL. Takes ownership of the pointer and marks it to be
    /// freed on drop.
    #[allow(dead_code)]
    pub fn from_ptr(ptr: *mut OSSL_PARAM) -> Result<OsslParam<'static>, Error> {
        if ptr.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        /* get num of elements */
        let mut nelem = 0;
        let mut counter = ptr;
        unsafe {
            while !(*counter).key.is_null() {
                nelem += 1;
                counter = counter.offset(1);
            }
        }
        /* Mark as finalized as no changes are allowed to imported params */
        Ok(OsslParam {
            v: Vec::new(),
            p: Cow::Borrowed(unsafe {
                std::slice::from_raw_parts(ptr, nelem + 1)
            }),
            finalized: true,
            zeroize: false,
            freeptr: true,
            br: Vec::new(),
        })
    }

    /// Creates an empty, finalized `OsslParam` array (contains only the end
    /// marker).
    #[allow(dead_code)]
    pub fn empty() -> OsslParam<'static> {
        let mut p = OsslParam {
            v: Vec::new(),
            p: Cow::Owned(Vec::with_capacity(1)),
            finalized: false,
            zeroize: false,
            freeptr: false,
            br: Vec::new(),
        };
        p.finalize();
        p
    }

    /// Adds a BIGNUM parameter from a big-endian byte vector.
    ///
    /// Handles the necessary conversions for OpenSSL's native-endian BIGNUM
    /// representation within `OSSL_PARAM`.
    pub fn add_bn(&mut self, key: &CStr, v: &Vec<u8>) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        /* need to go through all these functions because,
         * BN_bin2bn() takes a Big Endian number,
         * but BN_bn2nativepad() later will convert it to
         * native endianness, ensuring the buffer we pass in
         * is in the correct order for openssl ...
         */
        let bn = BigNum::from_bigendian_vec(v)?;
        let container = bn.to_native_vec()?;
        let param = unsafe {
            OSSL_PARAM_construct_BN(
                key.as_ptr(),
                void_ptr!(container.as_ptr()) as *mut u8,
                container.len(),
            )
        };
        self.v.push(container);
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Adds a UTF-8 string parameter using a borrowed byte vector reference.
    #[allow(dead_code)]
    pub fn add_utf8_string(
        &mut self,
        key: &CStr,
        v: &'a Vec<u8>,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_utf8_string(
                key.as_ptr(),
                void_ptr!(v.as_ptr()) as *mut c_char,
                0,
            )
        };
        self.p.to_mut().push(param);
        self.br.push(BorrowedReference::Vector(v));
        Ok(())
    }

    /// Adds a UTF-8 string parameter using an owned byte vector.
    #[allow(dead_code)]
    pub fn add_owned_utf8_string(
        &mut self,
        key: &CStr,
        mut v: Vec<u8>,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_utf8_string(
                key.as_ptr(),
                void_ptr!(v.as_mut_ptr()) as *mut c_char,
                0,
            )
        };
        self.v.push(v);
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Adds an empty sized string to receive values from queries like
    /// get_params()
    pub fn add_empty_utf8_string(
        &mut self,
        key: &CStr,
        len: usize,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let mut v = vec![0u8; len];
        let param = unsafe {
            OSSL_PARAM_construct_utf8_string(
                key.as_ptr(),
                void_ptr!(v.as_mut_ptr()) as *mut c_char,
                len,
            )
        };
        self.v.push(v);
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Adds a UTF-8 string parameter using a borrowed C string pointer.
    ///
    /// Assumes `key` and `val` point to valid, null-terminated C strings.
    /// The caller must ensure their lifetimes exceed the `OsslParam`'s usage.
    ///
    /// Should only be used with actual const strings.
    #[allow(dead_code)]
    pub fn add_const_c_string(
        &mut self,
        key: &CStr,
        val: &CStr,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_utf8_string(
                key.as_ptr(),
                val.as_ptr() as *mut c_char,
                0,
            )
        };
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Adds an octet string (byte array) parameter using a borrowed byte
    /// vector reference.
    ///
    /// The caller must ensure their lifetimes exceed the `OsslParam`'s usage.
    #[allow(dead_code)]
    pub fn add_octet_string(
        &mut self,
        key: &CStr,
        v: &'a Vec<u8>,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_octet_string(
                key.as_ptr(),
                void_ptr!(v.as_ptr()),
                v.len(),
            )
        };
        self.p.to_mut().push(param);
        self.br.push(BorrowedReference::Vector(v));
        Ok(())
    }

    /// Adds an octet string (byte array) parameter using an owned byte vector.
    #[allow(dead_code)]
    pub fn add_owned_octet_string(
        &mut self,
        key: &CStr,
        v: Vec<u8>,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_octet_string(
                key.as_ptr(),
                void_ptr!(v.as_ptr()),
                v.len(),
            )
        };
        self.v.push(v);
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Adds a `size_t` parameter using a borrowed reference.
    ///
    /// The caller must ensure the lifetime of `val` exceeds the `OsslParam`'s
    /// usage.
    #[allow(dead_code)]
    pub fn add_size_t(
        &mut self,
        key: &CStr,
        val: &'a usize,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_size_t(
                key.as_ptr(),
                val as *const _ as *mut usize,
            )
        };
        self.p.to_mut().push(param);
        self.br.push(BorrowedReference::Usize(val));
        Ok(())
    }

    /// Adds a `c_uint` parameter using a borrowed reference.
    ///
    /// The caller must ensure the lifetime of `val` exceeds the `OsslParam`'s
    /// usage.
    #[allow(dead_code)]
    pub fn add_uint(
        &mut self,
        key: &CStr,
        val: &'a c_uint,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_uint(
                key.as_ptr(),
                val as *const _ as *mut c_uint,
            )
        };
        self.p.to_mut().push(param);
        self.br.push(BorrowedReference::Uint(val));
        Ok(())
    }

    /// Adds a `c_int` parameter using a borrowed reference.
    ///
    /// The caller must ensure the lifetime of `val` exceeds the `OsslParam`'s
    /// usage.
    #[allow(dead_code)]
    pub fn add_int(&mut self, key: &CStr, val: &'a c_int) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let param = unsafe {
            OSSL_PARAM_construct_int(
                key.as_ptr(),
                val as *const _ as *mut c_int,
            )
        };
        self.p.to_mut().push(param);
        self.br.push(BorrowedReference::Int(val));
        Ok(())
    }

    /// Adds an `c_uint` parameter using an owned value.
    #[allow(dead_code)]
    pub fn add_owned_uint(
        &mut self,
        key: &CStr,
        val: c_uint,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let v = val.to_ne_bytes().to_vec();

        let param = unsafe {
            OSSL_PARAM_construct_uint(
                key.as_ptr(),
                v.as_ptr() as *const _ as *mut c_uint,
            )
        };
        self.v.push(v);
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Adds an `c_uint` parameter using an owned value.
    #[allow(dead_code)]
    pub fn add_owned_int(
        &mut self,
        key: &CStr,
        val: c_int,
    ) -> Result<(), Error> {
        if self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }

        let v = val.to_ne_bytes().to_vec();

        let param = unsafe {
            OSSL_PARAM_construct_int(
                key.as_ptr(),
                v.as_ptr() as *const _ as *mut c_int,
            )
        };
        self.v.push(v);
        self.p.to_mut().push(param);
        Ok(())
    }

    /// Finalizes the `OSSL_PARAM` array by adding the end marker.
    ///
    /// Must be called before `as_ptr` or `as_mut_ptr` can be safely used.
    pub fn finalize(&mut self) {
        if !self.finalized {
            self.p.to_mut().push(unsafe { OSSL_PARAM_construct_end() });
            self.finalized = true;
        }
    }

    /// Returns a const pointer to the finalized `OSSL_PARAM` array.
    ///
    /// Panics if the array has not been finalized.
    #[allow(dead_code)]
    pub fn as_ptr(&self) -> *const OSSL_PARAM {
        if !self.finalized {
            panic!("Unfinalized OsslParam");
        }
        self.p.as_ref().as_ptr()
    }

    /// Returns a mutable pointer to the finalized `OSSL_PARAM` array.
    ///
    /// Panics if the array has not been finalized.
    #[allow(dead_code)]
    pub fn as_mut_ptr(&mut self) -> *mut OSSL_PARAM {
        if !self.finalized {
            panic!("Unfinalized OsslParam");
        }
        self.p.to_mut().as_mut_ptr()
    }

    /// Internal functions to convert an immutable reference to a mutable
    /// pointer. This is only used for interfaces that bindgen automatically
    /// mark as mutable but we know the interface contract means the pointer
    /// is effectively a const.
    unsafe fn int_mut_ptr(&self) -> *mut OSSL_PARAM {
        if !self.finalized {
            panic!("Unfinalized OsslParam");
        }
        self.p.as_ref().as_ptr() as *mut OSSL_PARAM
    }

    /// Gets the value of an integer parameter by its key name.
    #[allow(dead_code)]
    pub fn get_int(&self, key: &CStr) -> Result<c_int, Error> {
        if !self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        let p = unsafe { OSSL_PARAM_locate(self.int_mut_ptr(), key.as_ptr()) };
        if p.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let mut val: c_int = 0;
        let res = unsafe { OSSL_PARAM_get_int(p, &mut val) };
        if res != 1 {
            trace_ossl!("OSSL_PARAM_get_int()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(val)
    }

    /// Gets the value of a long parameter by its key name.
    #[allow(dead_code)]
    pub fn get_long(&self, key: &CStr) -> Result<c_long, Error> {
        if !self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        let p = unsafe { OSSL_PARAM_locate(self.int_mut_ptr(), key.as_ptr()) };
        if p.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let mut val: c_long = 0;
        let res = unsafe { OSSL_PARAM_get_long(p, &mut val) };
        if res != 1 {
            trace_ossl!("OSSL_PARAM_get_long()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(val)
    }

    /// Gets the value of a BIGNUM parameter by its key name as a big-endian
    /// byte vector.
    pub fn get_bn(&self, key: &CStr) -> Result<Vec<u8>, Error> {
        if !self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        let p = unsafe { OSSL_PARAM_locate(self.int_mut_ptr(), key.as_ptr()) };
        if p.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let bn = BigNum::from_param(p)?;
        bn.to_bigendian_vec()
    }

    /// Gets the value of an octet string parameter by its key name as a byte
    /// slice.
    #[allow(dead_code)]
    pub fn get_octet_string(&self, key: &CStr) -> Result<&'a [u8], Error> {
        if !self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        let p = unsafe { OSSL_PARAM_locate(self.int_mut_ptr(), key.as_ptr()) };
        if p.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let mut buf: *const c_void = std::ptr::null_mut();
        let mut buf_len: usize = 0;
        let res = unsafe {
            OSSL_PARAM_get_octet_string_ptr(p, &mut buf, &mut buf_len)
        };
        if res != 1 {
            trace_ossl!("OSSL_PARAM_get_octet_string_ptr()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        let octet =
            unsafe { std::slice::from_raw_parts(buf as *const u8, buf_len) };
        Ok(octet)
    }

    /// Gets a UTF8 String as vector, this includes the terminating NUL
    #[allow(dead_code)]
    pub fn get_utf8_string_as_vec(&self, key: &CStr) -> Result<Vec<u8>, Error> {
        if !self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        let p = unsafe { OSSL_PARAM_locate(self.int_mut_ptr(), key.as_ptr()) };
        if p.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let mut ptr: *const c_char = std::ptr::null_mut();
        let res = unsafe { OSSL_PARAM_get_utf8_string_ptr(p, &mut ptr) };
        if res != 1 {
            trace_ossl!("OSSL_PARAM_get_utf8_string_ptr()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        let s = unsafe { CStr::from_ptr(ptr) };
        Ok(s.to_bytes_with_nul().to_vec())
    }

    /// Checks if a parameter with the given key name exists in the array.
    #[allow(dead_code)]
    pub fn has_param(&self, key: &CStr) -> Result<bool, Error> {
        if !self.finalized {
            return Err(Error::new(ErrorKind::WrapperError));
        }
        let p = unsafe { OSSL_PARAM_locate(self.int_mut_ptr(), key.as_ptr()) };
        if p.is_null() {
            Ok(false)
        } else {
            Ok(true)
        }
    }
}

/// Wrapper around OpenSSL's `EVP_MD`, managing its lifecycle.
#[derive(Debug)]
pub struct EvpMd {
    ptr: *mut EVP_MD,
}

/// Methods for creating and accessing `EvpMd`.
impl EvpMd {
    pub fn new(ctx: &OsslContext, name: &CStr) -> Result<EvpMd, Error> {
        let ptr = unsafe {
            EVP_MD_fetch(ctx.ptr(), name.as_ptr(), std::ptr::null_mut())
        };
        if ptr.is_null() {
            trace_ossl!("EVP_MD_fetch()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpMd { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_MD`.
    pub unsafe fn as_ptr(&self) -> *const EVP_MD {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_MD`.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut EVP_MD {
        self.ptr
    }
}

impl Drop for EvpMd {
    fn drop(&mut self) {
        unsafe {
            EVP_MD_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpMd {}
unsafe impl Sync for EvpMd {}

/// Wrapper around OpenSSL's `EVP_MD_CTX`, managing its lifecycle.
#[derive(Debug)]
pub struct EvpMdCtx {
    ptr: *mut EVP_MD_CTX,
}

/// Methods for creating and accessing `EvpMdCtx`.
impl EvpMdCtx {
    pub fn new() -> Result<EvpMdCtx, Error> {
        let ptr = unsafe { EVP_MD_CTX_new() };
        if ptr.is_null() {
            trace_ossl!("EVP_MD_ctx_new()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpMdCtx { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_MD_CTX`.
    pub unsafe fn as_ptr(&self) -> *const EVP_MD_CTX {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_MD_CTX`.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut EVP_MD_CTX {
        self.ptr
    }
}

impl Drop for EvpMdCtx {
    fn drop(&mut self) {
        unsafe {
            EVP_MD_CTX_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpMdCtx {}
unsafe impl Sync for EvpMdCtx {}

/// Wrapper around OpenSSL's `EVP_CIPHER`, managing its lifecycle.
#[derive(Debug)]
pub struct EvpCipher {
    ptr: *mut EVP_CIPHER,
}

/// Methods for creating and accessing `EvpCipher`.
impl EvpCipher {
    pub fn new(ctx: &OsslContext, name: &CStr) -> Result<EvpCipher, Error> {
        let ptr = unsafe {
            EVP_CIPHER_fetch(ctx.ptr(), name.as_ptr(), std::ptr::null_mut())
        };
        if ptr.is_null() {
            trace_ossl!("EVP_CIPHER_fetch()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpCipher { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_CIPHER`.
    pub unsafe fn as_ptr(&self) -> *const EVP_CIPHER {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_CIPHER`.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut EVP_CIPHER {
        self.ptr
    }
}

impl Drop for EvpCipher {
    fn drop(&mut self) {
        unsafe {
            EVP_CIPHER_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpCipher {}
unsafe impl Sync for EvpCipher {}

/// Wrapper around OpenSSL's `EVP_CIPHER_CTX`, managing its lifecycle.
#[derive(Debug)]
pub struct EvpCipherCtx {
    ptr: *mut EVP_CIPHER_CTX,
}

/// Methods for creating and accessing `EvpCipherCtx`.
impl EvpCipherCtx {
    pub fn new() -> Result<EvpCipherCtx, Error> {
        let ptr = unsafe { EVP_CIPHER_CTX_new() };
        if ptr.is_null() {
            trace_ossl!("EVP_CIPHER_ctx_new()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpCipherCtx { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_CIPHER_CTX`.
    pub unsafe fn as_ptr(&self) -> *const EVP_CIPHER_CTX {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_CIPHER_CTX`.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut EVP_CIPHER_CTX {
        self.ptr
    }
}

impl Drop for EvpCipherCtx {
    fn drop(&mut self) {
        unsafe {
            EVP_CIPHER_CTX_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpCipherCtx {}
unsafe impl Sync for EvpCipherCtx {}

/// Wrapper around OpenSSL's `EVP_KDF_CTX`, managing its lifecycle.
#[derive(Debug)]
pub struct EvpKdfCtx {
    ptr: *mut EVP_KDF_CTX,
}

/// Methods for creating (from a named KDF) and accessing `EvpKdfCtx`.
impl EvpKdfCtx {
    pub fn new(ctx: &OsslContext, name: &CStr) -> Result<EvpKdfCtx, Error> {
        let arg = unsafe {
            EVP_KDF_fetch(ctx.ptr(), name.as_ptr(), std::ptr::null_mut())
        };
        if arg.is_null() {
            trace_ossl!("EVP_KDF_fetch()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let ptr = unsafe { EVP_KDF_CTX_new(arg) };
        unsafe {
            EVP_KDF_free(arg);
        }
        if ptr.is_null() {
            trace_ossl!("EVP_KDF_CTX_new()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpKdfCtx { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_KDF_CTX`.
    pub unsafe fn as_ptr(&self) -> *const EVP_KDF_CTX {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_KDF_CTX`.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut EVP_KDF_CTX {
        self.ptr
    }
}

impl Drop for EvpKdfCtx {
    fn drop(&mut self) {
        unsafe {
            EVP_KDF_CTX_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpKdfCtx {}
unsafe impl Sync for EvpKdfCtx {}

/// Wrapper around OpenSSL's `EVP_MAC_CTX`, managing its lifecycle.
#[derive(Debug)]
pub struct EvpMacCtx {
    ptr: *mut EVP_MAC_CTX,
}

/// Methods for creating (from a named MAC) and accessing `EvpMacCtx`.
impl EvpMacCtx {
    pub fn new(ctx: &OsslContext, name: &CStr) -> Result<EvpMacCtx, Error> {
        let arg = unsafe {
            EVP_MAC_fetch(ctx.ptr(), name.as_ptr(), std::ptr::null_mut())
        };
        if arg.is_null() {
            trace_ossl!("EVP_MAC_fetch()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        let ptr = unsafe { EVP_MAC_CTX_new(arg) };
        unsafe {
            EVP_MAC_free(arg);
        }
        if ptr.is_null() {
            trace_ossl!("EVP_MAC_CTX_new()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpMacCtx { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_MAC_CTX`.
    pub unsafe fn as_ptr(&self) -> *const EVP_MAC_CTX {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_MAC_CTX`.
    pub unsafe fn as_mut_ptr(&mut self) -> *mut EVP_MAC_CTX {
        self.ptr
    }
}

impl Drop for EvpMacCtx {
    fn drop(&mut self) {
        unsafe {
            EVP_MAC_CTX_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpMacCtx {}
unsafe impl Sync for EvpMacCtx {}

/// Wrapper around OpenSSL's `EVP_PKEY_CTX`, managing its lifecycle.
/// Used for various public key algorithm operations (key generation, signing,
/// encryption context setup, etc.).
#[derive(Debug)]
pub struct EvpPkeyCtx {
    ptr: *mut EVP_PKEY_CTX,
}

/// Methods for creating and accessing `EvpPkeyCtx`.
impl EvpPkeyCtx {
    /// Fecthes an algorithm by name and returns a wrapper `EvpPkeyCtx`
    pub fn new(ctx: &OsslContext, name: &CStr) -> Result<EvpPkeyCtx, Error> {
        let ptr = unsafe {
            EVP_PKEY_CTX_new_from_name(
                ctx.ptr(),
                name.as_ptr(),
                std::ptr::null(),
            )
        };
        if ptr.is_null() {
            trace_ossl!("EVP_PKEY_CTX_new_from_name()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpPkeyCtx { ptr: ptr })
    }

    /// Creates an `EvpPkeyCtx` from an existing raw pointer (takes ownership).
    pub unsafe fn from_ptr(
        ptr: *mut EVP_PKEY_CTX,
    ) -> Result<EvpPkeyCtx, Error> {
        if ptr.is_null() {
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpPkeyCtx { ptr: ptr })
    }

    /// Returns a const pointer to the underlying `EVP_PKEY_CTX`.
    #[allow(dead_code)]
    pub fn as_ptr(&self) -> *const EVP_PKEY_CTX {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_PKEY_CTX`.
    pub fn as_mut_ptr(&mut self) -> *mut EVP_PKEY_CTX {
        self.ptr
    }
}

impl Drop for EvpPkeyCtx {
    fn drop(&mut self) {
        unsafe {
            EVP_PKEY_CTX_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpPkeyCtx {}
unsafe impl Sync for EvpPkeyCtx {}

/// Wrapper around OpenSSL's `EVP_PKEY`, representing a generic public or
/// private key. Manages the key's lifecycle.
#[derive(Debug)]
pub struct EvpPkey {
    ptr: *mut EVP_PKEY,
}

impl EvpPkey {
    /// Creates an `EvpPkey` from key material provided via `OSSL_PARAM`s.
    ///
    /// Used for importing public or private keys based on their components
    /// (e.g., modulus/exponent for RSA, curve/point for EC).
    pub fn fromdata(
        ctx: &OsslContext,
        pkey_name: &CStr,
        pkey_type: u32,
        params: &OsslParam,
    ) -> Result<EvpPkey, Error> {
        let mut pctx = EvpPkeyCtx::new(ctx, pkey_name)?;
        let res = unsafe { EVP_PKEY_fromdata_init(pctx.as_mut_ptr()) };
        if res != 1 {
            trace_ossl!("EVP_PKEY_fromdata_init()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        let mut pkey: *mut EVP_PKEY = std::ptr::null_mut();
        let res = unsafe {
            EVP_PKEY_fromdata(
                pctx.as_mut_ptr(),
                &mut pkey,
                pkey_type as i32,
                params.as_ptr() as *mut OSSL_PARAM,
            )
        };
        if res != 1 {
            trace_ossl!("EVP_PKEY_fromdata()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(EvpPkey { ptr: pkey })
    }

    /// Exports key material components into an `OsslParam` structure.
    ///
    /// The `selection` argument specifies which components to export
    /// (e.g., public, private, parameters).
    pub fn todata(&self, selection: u32) -> Result<OsslParam, Error> {
        let mut params: *mut OSSL_PARAM = std::ptr::null_mut();
        let ret = unsafe {
            EVP_PKEY_todata(self.ptr, c_int::try_from(selection)?, &mut params)
        };
        if ret != 1 {
            trace_ossl!("EVP_PKEY_todata()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        OsslParam::from_ptr(params)
    }

    /// Allow to get parameters from a key.
    /// The caller must preallocate the payloads with enough space to
    /// receive the data, which is copied into the parameters.
    pub fn get_params(&self, params: &mut OsslParam) -> Result<(), Error> {
        if unsafe { EVP_PKEY_get_params(self.ptr, params.as_mut_ptr()) } != 1 {
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(())
    }

    /// Generates a new key pair based on provided algorithm name and
    /// parameters.
    ///
    /// The parameters (`OsslParam`) specify details like key size or curve
    /// name.
    pub fn generate(
        ctx: &OsslContext,
        pkey_name: &CStr,
        params: &OsslParam,
    ) -> Result<EvpPkey, Error> {
        let mut pctx = EvpPkeyCtx::new(ctx, pkey_name)?;
        let res = unsafe { EVP_PKEY_keygen_init(pctx.as_mut_ptr()) };
        if res != 1 {
            trace_ossl!("EVP_PKEY_keygen_init()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        let res = unsafe {
            EVP_PKEY_CTX_set_params(pctx.as_mut_ptr(), params.as_ptr())
        };
        if res != 1 {
            trace_ossl!("EVP_PKEY_CTX_set_params()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        let mut pkey: *mut EVP_PKEY = std::ptr::null_mut();
        let res = unsafe { EVP_PKEY_generate(pctx.as_mut_ptr(), &mut pkey) };
        if res != 1 {
            trace_ossl!("EVP_PKEY_generate()");
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(EvpPkey { ptr: pkey })
    }

    /// Creates a new `EvpPkeyCtx` associated with this `EvpPkey`.
    ///
    /// Used to prepare for operations using this specific key.
    pub fn new_ctx(&mut self, ctx: &OsslContext) -> Result<EvpPkeyCtx, Error> {
        /* this function takes care of checking for NULL */
        unsafe {
            EvpPkeyCtx::from_ptr(
                /* this function will use refcounting to keep EVP_PKEY
                 * alive for the lifetime of the context, so it is ok
                 * to not use rust lifetimes here */
                EVP_PKEY_CTX_new_from_pkey(
                    ctx.ptr(),
                    self.as_mut_ptr(),
                    std::ptr::null_mut(),
                ),
            )
        }
    }

    /// Returns a const pointer to the underlying `EVP_PKEY`.
    pub fn as_ptr(&self) -> *const EVP_PKEY {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_PKEY`.
    pub fn as_mut_ptr(&mut self) -> *mut EVP_PKEY {
        self.ptr
    }

    /// Gets the key size in bits. Handles FIPS provider differences.
    #[cfg(not(feature = "fips"))]
    pub fn get_bits(&self) -> Result<usize, Error> {
        let ret = unsafe { EVP_PKEY_get_bits(self.ptr) };
        if ret == 0 {
            /* TODO: may want to return a special error
             * for unsupported keys */
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(usize::try_from(ret)?)
    }
    #[cfg(feature = "fips")]
    pub fn get_bits(&self) -> Result<usize, Error> {
        /* EVP_PKEY_get_bits() not available in libfips.a */
        let mut bits: c_int = 0;
        let ret = unsafe {
            EVP_PKEY_get_int_param(
                self.ptr,
                OSSL_PKEY_PARAM_BITS.as_ptr() as *const c_char,
                &mut bits,
            )
        };
        if ret == 0 {
            /* TODO: may want to return a special error
             * for unsupported keys */
            return Err(Error::new(ErrorKind::OsslError));
        }
        Ok(usize::try_from(bits)?)
    }
}

impl Drop for EvpPkey {
    fn drop(&mut self) {
        unsafe {
            EVP_PKEY_free(self.ptr);
        }
    }
}

unsafe impl Send for EvpPkey {}
unsafe impl Sync for EvpPkey {}

/// Wrapper around OpenSSL's `EVP_SIGNATURE`, used for ML-DSA operations.
pub struct EvpSignature {
    ptr: *mut EVP_SIGNATURE,
}

impl EvpSignature {
    /// Creates a new `EvpSignature` instance by fetching it by name.
    pub fn new(ctx: &OsslContext, name: &CStr) -> Result<EvpSignature, Error> {
        let ptr: *mut EVP_SIGNATURE = unsafe {
            EVP_SIGNATURE_fetch(ctx.ptr(), name.as_ptr(), std::ptr::null_mut())
        };
        if ptr.is_null() {
            trace_ossl!("EVP_SIGNATURE_fetch()");
            return Err(Error::new(ErrorKind::NullPtr));
        }
        Ok(EvpSignature { ptr })
    }

    /// Returns a const pointer to the underlying `EVP_SIGNATURE`.
    #[allow(dead_code)]
    pub fn as_ptr(&self) -> *const EVP_SIGNATURE {
        self.ptr
    }

    /// Returns a mutable pointer to the underlying `EVP_SIGNATURE`.
    pub fn as_mut_ptr(&mut self) -> *mut EVP_SIGNATURE {
        self.ptr
    }
}

impl Drop for EvpSignature {
    fn drop(&mut self) {
        unsafe {
            EVP_SIGNATURE_free(self.ptr);
        }
    }
}

macro_rules! cstr {
    ($str:expr) => {
        unsafe { CStr::from_ptr($str.as_ptr() as *const c_char) }
    };
}

/// Known algorithms selectable for OsslSignature
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum SigAlg {
    Ecdsa,
    EcdsaSha1,
    EcdsaSha2_224,
    EcdsaSha2_256,
    EcdsaSha2_384,
    EcdsaSha2_512,
    EcdsaSha3_224,
    EcdsaSha3_256,
    EcdsaSha3_384,
    EcdsaSha3_512,
    Ed25519,
    Ed25519ctx,
    Ed25519ph,
    Ed448,
    Ed448ph,
    Mldsa44,
    Mldsa65,
    Mldsa87,
    Rsa,
    RsaNoPad,
    RsaSha1,
    RsaSha2_224,
    RsaSha2_256,
    RsaSha2_384,
    RsaSha2_512,
    RsaSha3_224,
    RsaSha3_256,
    RsaSha3_384,
    RsaSha3_512,
    RsaPss,
    RsaPssSha1,
    RsaPssSha2_224,
    RsaPssSha2_256,
    RsaPssSha2_384,
    RsaPssSha2_512,
    RsaPssSha3_224,
    RsaPssSha3_256,
    RsaPssSha3_384,
    RsaPssSha3_512,
}

/// Helper that indicates if a signature algorithm should use oneshot apis
fn sigalg_is_oneshot(alg: SigAlg) -> bool {
    match alg {
        SigAlg::Ecdsa | SigAlg::Rsa | SigAlg::RsaPss | SigAlg::RsaNoPad => true,
        _ => false,
    }
}

/// Helper that indicates if a signature algorithm should use legacy apis
fn sigalg_uses_legacy_api(alg: SigAlg) -> bool {
    #[cfg(not(ossl_v350))]
    match alg {
        SigAlg::Ecdsa | SigAlg::Rsa | SigAlg::RsaPss | SigAlg::RsaNoPad => {
            false
        }
        SigAlg::Mldsa44 | SigAlg::Mldsa65 | SigAlg::Mldsa87 => false,
        _ => true,
    }
    #[cfg(ossl_v350)]
    match alg {
        SigAlg::RsaPssSha1
        | SigAlg::RsaPssSha2_224
        | SigAlg::RsaPssSha2_256
        | SigAlg::RsaPssSha2_384
        | SigAlg::RsaPssSha3_224
        | SigAlg::RsaPssSha3_256
        | SigAlg::RsaPssSha3_384
        | SigAlg::RsaPssSha3_512 => true,
        _ => false,
    }
}

/// Helper that indicates is a signature algorithm supports updates
/// a value of None indicates autodetection should be performed
fn sigalg_supports_updates(alg: SigAlg) -> Option<bool> {
    match alg {
        SigAlg::Ecdsa
        | SigAlg::Ed25519
        | SigAlg::Ed25519ctx
        | SigAlg::Ed25519ph
        | SigAlg::Ed448
        | SigAlg::Ed448ph
        | SigAlg::Rsa
        | SigAlg::RsaPss
        | SigAlg::RsaNoPad => Some(false),
        SigAlg::Mldsa44 | SigAlg::Mldsa65 | SigAlg::Mldsa87 => None,
        _ => Some(true),
    }
}

static ECDSA_NAME: &CStr = c"ECDSA";
static ECDSASHA1_NAME: &CStr = c"ECDSA-SHA1";
static ECDSASHA2_224_NAME: &CStr = c"ECDSA-SHA2-224";
static ECDSASHA2_256_NAME: &CStr = c"ECDSA-SHA2-256";
static ECDSASHA2_384_NAME: &CStr = c"ECDSA-SHA2-384";
static ECDSASHA2_512_NAME: &CStr = c"ECDSA-SHA2-512";
static ECDSASHA3_224_NAME: &CStr = c"ECDSA-SHA3-224";
static ECDSASHA3_256_NAME: &CStr = c"ECDSA-SHA3-256";
static ECDSASHA3_384_NAME: &CStr = c"ECDSA-SHA3-384";
static ECDSASHA3_512_NAME: &CStr = c"ECDSA-SHA3-512";
static ED25519_NAME: &CStr = c"ED25519";
static ED25519CTX_NAME: &CStr = c"ED25519CTX";
static ED25519PH_NAME: &CStr = c"ED25519PH";
static ED448_NAME: &CStr = c"ED448";
static ED448PH_NAME: &CStr = c"ED448PH";
static MLDSA44_NAME: &CStr = c"ML-DSA-44";
static MLDSA65_NAME: &CStr = c"ML-DSA-65";
static MLDSA87_NAME: &CStr = c"ML-DSA-87";
static RSA_NAME: &CStr = c"RSA";
static RSASHA1_NAME: &CStr = c"RSA-SHA1";
static RSASHA2_224_NAME: &CStr = c"RSA-SHA2-224";
static RSASHA2_256_NAME: &CStr = c"RSA-SHA2-256";
static RSASHA2_384_NAME: &CStr = c"RSA-SHA2-384";
static RSASHA2_512_NAME: &CStr = c"RSA-SHA2-512";
static RSASHA3_224_NAME: &CStr = c"RSA-SHA3-224";
static RSASHA3_256_NAME: &CStr = c"RSA-SHA3-256";
static RSASHA3_384_NAME: &CStr = c"RSA-SHA3-384";
static RSASHA3_512_NAME: &CStr = c"RSA-SHA3-512";
/* The following names are not actually recognized by
 * OpenSSL and will cause a fetch error if used, they
 * have been made up for completeness, and debugging */
static RSAPSS_NAME: &CStr = c"RSA-PSS";
static RSAPSSSHA1_NAME: &CStr = c"RSA-PSS-SHA1";
static RSAPSSSHA2_224_NAME: &CStr = c"RSA-PSS-SHA2-224";
static RSAPSSSHA2_256_NAME: &CStr = c"RSA-PSS-SHA2-256";
static RSAPSSSHA2_384_NAME: &CStr = c"RSA-PSS-SHA2-384";
static RSAPSSSHA2_512_NAME: &CStr = c"RSA-PSS-SHA2-512";
static RSAPSSSHA3_224_NAME: &CStr = c"RSA-PSS-SHA3-224";
static RSAPSSSHA3_256_NAME: &CStr = c"RSA-PSS-SHA3-256";
static RSAPSSSHA3_384_NAME: &CStr = c"RSA-PSS-SHA3-384";
static RSAPSSSHA3_512_NAME: &CStr = c"RSA-PSS-SHA3-512";
static RSANOPAD_NAME: &CStr = c"RSA-NO-PAD";

/// Helper to return OpenSSL sigalg name
fn sigalg_to_ossl_name(alg: SigAlg) -> &'static CStr {
    match alg {
        SigAlg::Ecdsa => ECDSA_NAME,
        SigAlg::EcdsaSha1 => ECDSASHA1_NAME,
        SigAlg::EcdsaSha2_224 => ECDSASHA2_224_NAME,
        SigAlg::EcdsaSha2_256 => ECDSASHA2_256_NAME,
        SigAlg::EcdsaSha2_384 => ECDSASHA2_384_NAME,
        SigAlg::EcdsaSha2_512 => ECDSASHA2_512_NAME,
        SigAlg::EcdsaSha3_224 => ECDSASHA3_224_NAME,
        SigAlg::EcdsaSha3_256 => ECDSASHA3_256_NAME,
        SigAlg::EcdsaSha3_384 => ECDSASHA3_384_NAME,
        SigAlg::EcdsaSha3_512 => ECDSASHA3_512_NAME,
        SigAlg::Ed25519 => ED25519_NAME,
        SigAlg::Ed25519ctx => ED25519CTX_NAME,
        SigAlg::Ed25519ph => ED25519PH_NAME,
        SigAlg::Ed448 => ED448_NAME,
        SigAlg::Ed448ph => ED448PH_NAME,
        SigAlg::Mldsa44 => MLDSA44_NAME,
        SigAlg::Mldsa65 => MLDSA65_NAME,
        SigAlg::Mldsa87 => MLDSA87_NAME,
        SigAlg::Rsa => RSA_NAME,
        SigAlg::RsaSha1 => RSASHA1_NAME,
        SigAlg::RsaSha2_224 => RSASHA2_224_NAME,
        SigAlg::RsaSha2_256 => RSASHA2_256_NAME,
        SigAlg::RsaSha2_384 => RSASHA2_384_NAME,
        SigAlg::RsaSha2_512 => RSASHA2_512_NAME,
        SigAlg::RsaSha3_224 => RSASHA3_224_NAME,
        SigAlg::RsaSha3_256 => RSASHA3_256_NAME,
        SigAlg::RsaSha3_384 => RSASHA3_384_NAME,
        SigAlg::RsaSha3_512 => RSASHA3_512_NAME,
        SigAlg::RsaPss => RSAPSS_NAME,
        SigAlg::RsaPssSha1 => RSAPSSSHA1_NAME,
        SigAlg::RsaPssSha2_224 => RSAPSSSHA2_224_NAME,
        SigAlg::RsaPssSha2_256 => RSAPSSSHA2_256_NAME,
        SigAlg::RsaPssSha2_384 => RSAPSSSHA2_384_NAME,
        SigAlg::RsaPssSha2_512 => RSAPSSSHA2_512_NAME,
        SigAlg::RsaPssSha3_224 => RSAPSSSHA3_224_NAME,
        SigAlg::RsaPssSha3_256 => RSAPSSSHA3_256_NAME,
        SigAlg::RsaPssSha3_384 => RSAPSSSHA3_384_NAME,
        SigAlg::RsaPssSha3_512 => RSAPSSSHA3_512_NAME,
        SigAlg::RsaNoPad => RSANOPAD_NAME,
    }
}

/// Helper that returns the OpenSSL digest name associated to a sigalg
fn sigalg_to_digest_ptr(alg: SigAlg) -> *const c_char {
    match alg {
        SigAlg::EcdsaSha1 | SigAlg::RsaSha1 | SigAlg::RsaPssSha1 => {
            cstr!(OSSL_DIGEST_NAME_SHA1).as_ptr()
        }
        SigAlg::EcdsaSha2_224
        | SigAlg::RsaSha2_224
        | SigAlg::RsaPssSha2_224 => cstr!(OSSL_DIGEST_NAME_SHA2_224).as_ptr(),
        SigAlg::EcdsaSha2_256
        | SigAlg::RsaSha2_256
        | SigAlg::RsaPssSha2_256 => cstr!(OSSL_DIGEST_NAME_SHA2_256).as_ptr(),
        SigAlg::EcdsaSha2_384
        | SigAlg::RsaSha2_384
        | SigAlg::RsaPssSha2_384 => cstr!(OSSL_DIGEST_NAME_SHA2_384).as_ptr(),
        SigAlg::EcdsaSha2_512
        | SigAlg::RsaSha2_512
        | SigAlg::RsaPssSha2_512 => cstr!(OSSL_DIGEST_NAME_SHA2_512).as_ptr(),
        SigAlg::EcdsaSha3_224
        | SigAlg::RsaSha3_224
        | SigAlg::RsaPssSha3_224 => cstr!(OSSL_DIGEST_NAME_SHA3_224).as_ptr(),
        SigAlg::EcdsaSha3_256
        | SigAlg::RsaSha3_256
        | SigAlg::RsaPssSha3_256 => cstr!(OSSL_DIGEST_NAME_SHA3_256).as_ptr(),
        SigAlg::EcdsaSha3_384
        | SigAlg::RsaSha3_384
        | SigAlg::RsaPssSha3_384 => cstr!(OSSL_DIGEST_NAME_SHA3_384).as_ptr(),
        SigAlg::EcdsaSha3_512
        | SigAlg::RsaSha3_512
        | SigAlg::RsaPssSha3_512 => cstr!(OSSL_DIGEST_NAME_SHA3_512).as_ptr(),
        SigAlg::Mldsa44
        | SigAlg::Mldsa65
        | SigAlg::Mldsa87
        | SigAlg::Ecdsa
        | SigAlg::Ed25519
        | SigAlg::Ed25519ctx
        | SigAlg::Ed25519ph
        | SigAlg::Ed448
        | SigAlg::Ed448ph
        | SigAlg::Rsa
        | SigAlg::RsaPss
        | SigAlg::RsaNoPad => std::ptr::null(),
    }
}

pub struct RsaPssParams {
    pub digest: &'static CStr,
    pub mgf1: &'static CStr,
    pub saltlen: c_int,
}

/// Helper to generate OsslParam arrays for initialization
pub fn rsa_sig_params(
    alg: SigAlg,
    pss_params: &Option<RsaPssParams>,
) -> Result<Option<OsslParam>, Error> {
    match alg {
        SigAlg::RsaNoPad => {
            let mut params = OsslParam::new();
            params.add_const_c_string(
                cstr!(OSSL_SIGNATURE_PARAM_PAD_MODE),
                cstr!(OSSL_PKEY_RSA_PAD_MODE_NONE),
            )?;
            params.finalize();
            return Ok(Some(params));
        }
        SigAlg::Rsa
        | SigAlg::RsaSha1
        | SigAlg::RsaSha2_224
        | SigAlg::RsaSha2_256
        | SigAlg::RsaSha2_384
        | SigAlg::RsaSha3_224
        | SigAlg::RsaSha3_256
        | SigAlg::RsaSha3_384
        | SigAlg::RsaSha3_512 => {
            /* In 3.5.0 there is direct sigalg support for
             * PCKCS1 padding for digest algorithms so no
             * paramters are needed or processed */
            #[cfg(ossl_v350)]
            if alg != SigAlg::Rsa {
                return Ok(None);
            }

            let mut params = OsslParam::new();
            params.add_const_c_string(
                cstr!(OSSL_SIGNATURE_PARAM_PAD_MODE),
                cstr!(OSSL_PKEY_RSA_PAD_MODE_PKCSV15),
            )?;
            params.finalize();
            return Ok(Some(params));
        }
        SigAlg::RsaPss
        | SigAlg::RsaPssSha1
        | SigAlg::RsaPssSha2_224
        | SigAlg::RsaPssSha2_256
        | SigAlg::RsaPssSha2_384
        | SigAlg::RsaPssSha3_224
        | SigAlg::RsaPssSha3_256
        | SigAlg::RsaPssSha3_384
        | SigAlg::RsaPssSha3_512 => {
            /* Pss always uses legacy interfaces, so we need
             * all params set up */
            if let Some(pss) = pss_params {
                let mut params = OsslParam::new();

                params.add_const_c_string(
                    cstr!(OSSL_SIGNATURE_PARAM_PAD_MODE),
                    cstr!(OSSL_PKEY_RSA_PAD_MODE_PSS),
                )?;
                params.add_const_c_string(
                    cstr!(OSSL_SIGNATURE_PARAM_DIGEST),
                    pss.digest,
                )?;
                params.add_const_c_string(
                    cstr!(OSSL_SIGNATURE_PARAM_MGF1_DIGEST),
                    pss.mgf1,
                )?;
                params.add_owned_int(
                    cstr!(OSSL_SIGNATURE_PARAM_PSS_SALTLEN),
                    pss.saltlen,
                )?;
                params.finalize();
                return Ok(Some(params));
            } else {
                return Err(Error::new(ErrorKind::NullPtr));
            }
        }
        _ => Err(Error::new(ErrorKind::WrapperError)),
    }
}

/// Helper to generate OsslParam arrays for Eddsa initialization
#[cfg(ossl_v320)]
pub fn eddsa_params(
    alg: SigAlg,
    context: Option<Vec<u8>>,
) -> Result<Option<OsslParam<'static>>, Error> {
    match alg {
        SigAlg::Ed25519
        | SigAlg::Ed25519ph
        | SigAlg::Ed448
        | SigAlg::Ed448ph
        | SigAlg::Ed25519ctx => (),
        _ => return Err(Error::new(ErrorKind::WrapperError)),
    }

    /* With 3.5.0 we use the sigalg interface so no need
     * for params */
    #[cfg(ossl_v350)]
    if context.is_none() {
        return Ok(None);
    }

    let mut params = OsslParam::new();

    #[cfg(not(ossl_v350))]
    params.add_const_c_string(
        cstr!(OSSL_SIGNATURE_PARAM_INSTANCE),
        sigalg_to_ossl_name(alg),
    )?;

    if let Some(v) = context {
        params.add_owned_octet_string(
            cstr!(OSSL_SIGNATURE_PARAM_CONTEXT_STRING),
            v,
        )?;
    }

    params.finalize();
    return Ok(Some(params));
}

/// Maximum buffer size for accumulating data when emulating multi-part
/// operations for OpenSSL versions that only support one-shot operations.
const MAX_BUFFER_LEN: usize = 1024 * 1024;

/// Higher level wrapper for signature operations with OpenSSL
#[derive(Debug)]
pub struct OsslSignature {
    /// The underlying OpenSSL EVP PKEY context.
    pkey_ctx: EvpPkeyCtx,
    /// The MD Ctx for cases when the old EVP_Digest interfaces need to be used
    #[cfg(not(feature = "fips"))]
    legacy_ctx: Option<EvpMdCtx>,
    #[cfg(feature = "fips")]
    legacy_ctx: Option<fips::ProviderSignatureCtx>,
    /// Flag indicating if the current OpenSSL version supports multi-part
    /// updates.
    supports_updates: bool,
    /// Buffer to accumulate data for multi-part emulation if needed.
    data: Option<Vec<u8>>,
    /// Stored signature for VerifySignature operations if updates aren't
    /// supported by the OpenSSL provider.
    signature: Option<Vec<u8>>,
}

impl OsslSignature {
    /// Internal function to init the structure from a key
    fn init(
        ctx: &OsslContext,
        key: &mut EvpPkey,
    ) -> Result<OsslSignature, Error> {
        Ok(OsslSignature {
            pkey_ctx: key.new_ctx(ctx)?,
            legacy_ctx: None,
            supports_updates: false,
            data: None,
            signature: None,
        })
    }

    /// Accumulates data when native update is not available
    fn store_data(&mut self, data: &[u8]) -> Result<(), Error> {
        match &mut self.data {
            Some(buffer) => {
                if buffer.len() + data.len() > MAX_BUFFER_LEN {
                    return Err(Error::new(ErrorKind::BufferSize));
                }
                buffer.extend_from_slice(data);
            }
            None => {
                if data.len() > MAX_BUFFER_LEN {
                    return Err(Error::new(ErrorKind::BufferSize));
                }
                self.data = Some(data.to_vec());
            }
        }

        Ok(())
    }

    /// Creates a new message sign context for a specific
    /// algorithm name, requires a private key and parameters.
    pub fn message_sign_new(
        libctx: &OsslContext,
        alg: SigAlg,
        key: &mut EvpPkey,
        params: Option<&OsslParam>,
    ) -> Result<OsslSignature, Error> {
        let mut ctx = Self::init(libctx, key)?;

        if sigalg_is_oneshot(alg) {
            /* Single shot algorithms must always use EVP_PKEY_sign_init */
            if unsafe { EVP_PKEY_sign_init(ctx.pkey_ctx.as_mut_ptr()) } != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }
            if let Some(p) = params {
                let ret = unsafe {
                    EVP_PKEY_CTX_set_params(
                        ctx.pkey_ctx.as_mut_ptr(),
                        p.as_ptr(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
            return Ok(ctx);
        }

        if sigalg_uses_legacy_api(alg) {
            #[cfg(not(feature = "fips"))]
            {
                let mut lctx = EvpMdCtx::new()?;
                let ret = unsafe {
                    EVP_DigestSignInit_ex(
                        lctx.as_mut_ptr(),
                        std::ptr::null_mut(),
                        sigalg_to_digest_ptr(alg),
                        libctx.ptr(),
                        std::ptr::null(),
                        key.as_mut_ptr(),
                        match params {
                            Some(p) => p.as_ptr(),
                            None => std::ptr::null(),
                        },
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
                ctx.legacy_ctx = Some(lctx);
            }
            #[cfg(feature = "fips")]
            {
                let mut lctx = fips::ProviderSignatureCtx::new(alg)?;
                lctx.digest_sign_init(
                    sigalg_to_digest_ptr(alg),
                    key,
                    match params {
                        Some(p) => p.as_ptr(),
                        None => std::ptr::null(),
                    },
                )?;
                ctx.legacy_ctx = Some(lctx);
            }
            ctx.supports_updates = match sigalg_supports_updates(alg) {
                Some(true) => true,
                Some(false) => false,
                None => false,
            };
            return Ok(ctx);
        }

        #[cfg(ossl_v350)]
        {
            let ret = unsafe {
                EVP_PKEY_sign_message_init(
                    ctx.pkey_ctx.as_mut_ptr(),
                    EvpSignature::new(libctx, sigalg_to_ossl_name(alg))?
                        .as_mut_ptr(),
                    match params {
                        Some(p) => p.as_ptr(),
                        None => std::ptr::null(),
                    },
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }
            ctx.supports_updates = match sigalg_supports_updates(alg) {
                Some(true) => true,
                Some(false) => false,
                None => {
                    /* OpenSSL 3.5 implements only one shot ML-DSA,
                     * while later implementations can deal with
                     * update()/final() operations. Probe here, and
                     * set up a backup buffer if update()s are not
                     * supported.
                     */
                    let ret = unsafe {
                        EVP_PKEY_sign_message_update(
                            ctx.pkey_ctx.as_mut_ptr(),
                            std::ptr::null(),
                            0,
                        )
                    };
                    ret == 1
                }
            };
            return Ok(ctx);
        }

        #[cfg(not(ossl_v350))]
        Err(Error::new(ErrorKind::WrapperError))
    }

    /// One shot signature, takes data and a buffer where to store
    /// the signature. The signature buffer must have enough space
    /// to receive the signature. On success the siganture length is
    /// returned.
    pub fn message_sign(
        &mut self,
        data: &[u8],
        signature: Option<&mut [u8]>,
    ) -> Result<usize, Error> {
        let mut siglen = match &signature {
            Some(sig) => sig.len(),
            None => 0,
        };
        let siglen_ptr: *mut usize = &mut siglen;

        /* check siglen buffer is enough */
        if let Some(ctx) = &mut self.legacy_ctx {
            #[cfg(not(feature = "fips"))]
            {
                let ret = unsafe {
                    EVP_DigestSign(
                        ctx.as_mut_ptr(),
                        std::ptr::null_mut(),
                        siglen_ptr,
                        data.as_ptr(),
                        data.len(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
            #[cfg(feature = "fips")]
            {
                siglen = ctx.digest_sign(None, data)?;
            }
        } else {
            let ret = unsafe {
                EVP_PKEY_sign(
                    self.pkey_ctx.as_mut_ptr(),
                    std::ptr::null_mut(),
                    siglen_ptr,
                    data.as_ptr(),
                    data.len(),
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }
        }

        if let Some(sig) = signature {
            if siglen > sig.len() {
                return Err(Error::new(ErrorKind::BufferSize));
            }

            if let Some(ctx) = &mut self.legacy_ctx {
                #[cfg(not(feature = "fips"))]
                {
                    let ret = unsafe {
                        EVP_DigestSign(
                            ctx.as_mut_ptr(),
                            sig.as_mut_ptr(),
                            siglen_ptr,
                            data.as_ptr(),
                            data.len(),
                        )
                    };
                    if ret != 1 {
                        return Err(Error::new(ErrorKind::OsslError));
                    }
                }
                #[cfg(feature = "fips")]
                {
                    siglen = ctx.digest_sign(Some(sig), data)?;
                }
            } else {
                let ret = unsafe {
                    EVP_PKEY_sign(
                        self.pkey_ctx.as_mut_ptr(),
                        sig.as_mut_ptr(),
                        siglen_ptr,
                        data.as_ptr(),
                        data.len(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
        }

        Ok(siglen)
    }

    /// Feeds data to the message sign provider
    pub fn message_sign_update(&mut self, data: &[u8]) -> Result<(), Error> {
        if !self.supports_updates {
            return self.store_data(data);
        }

        if let Some(ctx) = &mut self.legacy_ctx {
            #[cfg(not(feature = "fips"))]
            {
                let ret = unsafe {
                    EVP_DigestSignUpdate(
                        ctx.as_mut_ptr(),
                        data.as_ptr() as *const c_void,
                        data.len(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
            #[cfg(feature = "fips")]
            ctx.digest_sign_update(data)?;

            return Ok(());
        }

        #[cfg(ossl_v350)]
        {
            let ret = unsafe {
                EVP_PKEY_sign_message_update(
                    self.pkey_ctx.as_mut_ptr(),
                    data.as_ptr(),
                    data.len(),
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }

            return Ok(());
        }

        #[cfg(not(ossl_v350))]
        Err(Error::new(ErrorKind::WrapperError))
    }

    /// Finalizes data and generates signature
    pub fn message_sign_final(
        &mut self,
        signature: &mut [u8],
    ) -> Result<usize, Error> {
        if !self.supports_updates {
            if let Some(buffer) = self.data.take() {
                return self.message_sign(buffer.as_slice(), Some(signature));
            }

            return Err(Error::new(ErrorKind::WrapperError));
        }

        if let Some(ctx) = &mut self.legacy_ctx {
            #[cfg(not(feature = "fips"))]
            {
                let mut siglen = signature.len();
                let siglen_ptr: *mut usize = &mut siglen;

                let ret = unsafe {
                    EVP_DigestSignFinal(
                        ctx.as_mut_ptr(),
                        signature.as_mut_ptr(),
                        siglen_ptr,
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
                return Ok(siglen);
            }
            #[cfg(feature = "fips")]
            return ctx.digest_sign_final(signature);
        }

        #[cfg(ossl_v350)]
        {
            let mut siglen = signature.len();
            let siglen_ptr: *mut usize = &mut siglen;

            let ret = unsafe {
                EVP_PKEY_sign_message_final(
                    self.pkey_ctx.as_mut_ptr(),
                    signature.as_mut_ptr(),
                    siglen_ptr,
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }

            return Ok(siglen);
        }

        #[cfg(not(ossl_v350))]
        Err(Error::new(ErrorKind::WrapperError))
    }

    /// Creates a new message verify context for a specific
    /// algorithm name, requires a public key and parameters.
    pub fn message_verify_new(
        libctx: &OsslContext,
        alg: SigAlg,
        key: &mut EvpPkey,
        params: Option<&OsslParam>,
    ) -> Result<OsslSignature, Error> {
        let mut ctx = Self::init(libctx, key)?;

        if sigalg_is_oneshot(alg) {
            /* Single shot algorithms must always use EVP_PKEY_verify_init */
            if unsafe { EVP_PKEY_verify_init(ctx.pkey_ctx.as_mut_ptr()) } != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }
            if let Some(p) = params {
                let ret = unsafe {
                    EVP_PKEY_CTX_set_params(
                        ctx.pkey_ctx.as_mut_ptr(),
                        p.as_ptr(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
            return Ok(ctx);
        }

        if sigalg_uses_legacy_api(alg) {
            #[cfg(not(feature = "fips"))]
            {
                let mut lctx = EvpMdCtx::new()?;
                let ret = unsafe {
                    EVP_DigestVerifyInit_ex(
                        lctx.as_mut_ptr(),
                        std::ptr::null_mut(),
                        sigalg_to_digest_ptr(alg),
                        libctx.ptr(),
                        std::ptr::null(),
                        key.as_mut_ptr(),
                        match params {
                            Some(p) => p.as_ptr(),
                            None => std::ptr::null(),
                        },
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
                ctx.legacy_ctx = Some(lctx);
            }
            #[cfg(feature = "fips")]
            {
                let mut lctx = fips::ProviderSignatureCtx::new(alg)?;
                lctx.digest_verify_init(
                    sigalg_to_digest_ptr(alg),
                    key,
                    match params {
                        Some(p) => p.as_ptr(),
                        None => std::ptr::null(),
                    },
                )?;
                ctx.legacy_ctx = Some(lctx);
            }
            ctx.supports_updates = match sigalg_supports_updates(alg) {
                Some(true) => true,
                Some(false) => false,
                None => false,
            };
            return Ok(ctx);
        }

        #[cfg(ossl_v350)]
        {
            let ret = unsafe {
                EVP_PKEY_verify_message_init(
                    ctx.pkey_ctx.as_mut_ptr(),
                    EvpSignature::new(libctx, sigalg_to_ossl_name(alg))?
                        .as_mut_ptr(),
                    match params {
                        Some(p) => p.as_ptr(),
                        None => std::ptr::null(),
                    },
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }
            ctx.supports_updates = match sigalg_supports_updates(alg) {
                Some(true) => true,
                Some(false) => false,
                None => {
                    /* OpenSSL 3.5 implements only one shot ML-DSA,
                     * while later implementations can deal with
                     * update()/final() operations. Probe here, and
                     * set up a backup buffer if update()s are not
                     * supported.
                     */
                    let ret = unsafe {
                        EVP_PKEY_verify_message_update(
                            ctx.pkey_ctx.as_mut_ptr(),
                            std::ptr::null(),
                            0,
                        )
                    };
                    ret == 1
                }
            };
            return Ok(ctx);
        }

        #[cfg(not(ossl_v350))]
        Err(Error::new(ErrorKind::WrapperError))
    }

    /// One shot verification function
    pub fn message_verify(
        &mut self,
        data: &[u8],
        signature: Option<&[u8]>,
    ) -> Result<(), Error> {
        let sig = match &signature {
            Some(s) => s,
            None => match &self.signature {
                Some(v) => v.as_slice(),
                None => return Err(Error::new(ErrorKind::WrapperError)),
            },
        };
        if let Some(ctx) = &mut self.legacy_ctx {
            #[cfg(not(feature = "fips"))]
            {
                let ret = unsafe {
                    EVP_DigestVerify(
                        ctx.as_mut_ptr(),
                        sig.as_ptr(),
                        sig.len(),
                        data.as_ptr(),
                        data.len(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
            #[cfg(feature = "fips")]
            {
                ctx.digest_verify(sig, data)?;
            }
        } else {
            let ret = unsafe {
                EVP_PKEY_verify(
                    self.pkey_ctx.as_mut_ptr(),
                    sig.as_ptr(),
                    sig.len(),
                    data.as_ptr(),
                    data.len(),
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }
        }
        Ok(())
    }

    /// Unsupported in versions of OpenSSL prior to 3.5.0
    #[cfg(not(ossl_v350))]
    pub fn set_signature(&mut self, _signature: &[u8]) -> Result<(), Error> {
        Err(Error::new(ErrorKind::WrapperError))
    }

    /// Sets the signature for a VerifySignature operation.
    /// If the OpenSSL backend supports setting it early (via
    /// `EVP_PKEY_CTX_set_signature`), it does so; otherwise, it stores the
    /// signature internally for later use.
    #[cfg(ossl_v350)]
    pub fn set_signature(&mut self, signature: &[u8]) -> Result<(), Error> {
        if self.legacy_ctx.is_some() || !self.supports_updates {
            self.signature = Some(signature.to_vec());
            return Ok(());
        }

        let ret = unsafe {
            EVP_PKEY_CTX_set_signature(
                self.pkey_ctx.as_mut_ptr(),
                signature.as_ptr(),
                signature.len(),
            )
        };
        if ret != 1 {
            return Err(Error::new(ErrorKind::OsslError));
        }

        Ok(())
    }

    /// Feeds data to the message verify provider
    pub fn message_verify_update(&mut self, data: &[u8]) -> Result<(), Error> {
        if !self.supports_updates {
            return self.store_data(data);
        }

        if let Some(ctx) = &mut self.legacy_ctx {
            #[cfg(not(feature = "fips"))]
            {
                let ret = unsafe {
                    EVP_DigestVerifyUpdate(
                        ctx.as_mut_ptr(),
                        data.as_ptr() as *const c_void,
                        data.len(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                }
            }
            #[cfg(feature = "fips")]
            ctx.digest_sign_update(data)?;

            return Ok(());
        }

        #[cfg(ossl_v350)]
        {
            let ret = unsafe {
                EVP_PKEY_verify_message_update(
                    self.pkey_ctx.as_mut_ptr(),
                    data.as_ptr(),
                    data.len(),
                )
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }

            return Ok(());
        }

        #[cfg(not(ossl_v350))]
        Err(Error::new(ErrorKind::WrapperError))
    }

    /// Finalizes data and generates signature
    pub fn message_verify_final(
        &mut self,
        signature: Option<&[u8]>,
    ) -> Result<(), Error> {
        if !self.supports_updates {
            if let Some(buffer) = self.data.take() {
                return self.message_verify(buffer.as_slice(), signature);
            }

            return Err(Error::new(ErrorKind::WrapperError));
        }

        if let Some(ctx) = &mut self.legacy_ctx {
            let sig = match &signature {
                Some(s) => s,
                None => match &self.signature {
                    Some(v) => v.as_slice(),
                    None => return Err(Error::new(ErrorKind::NullPtr)),
                },
            };
            #[cfg(not(feature = "fips"))]
            {
                let ret = unsafe {
                    EVP_DigestVerifyFinal(
                        ctx.as_mut_ptr(),
                        sig.as_ptr(),
                        sig.len(),
                    )
                };
                if ret != 1 {
                    return Err(Error::new(ErrorKind::OsslError));
                } else {
                    return Ok(());
                }
            }
            #[cfg(feature = "fips")]
            return ctx.digest_verify_final(sig);
        }

        #[cfg(ossl_v350)]
        {
            match signature {
                Some(sig) => {
                    self.set_signature(sig)?;
                }
                None => (),
            }

            let ret = unsafe {
                EVP_PKEY_verify_message_final(self.pkey_ctx.as_mut_ptr())
            };
            if ret != 1 {
                return Err(Error::new(ErrorKind::OsslError));
            }

            return Ok(());
        }

        #[cfg(not(ossl_v350))]
        Err(Error::new(ErrorKind::WrapperError))
    }
}
